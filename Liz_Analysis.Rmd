---
title: "Liz's Peak Bloom Prediction"
author: "Liz Conley"
date: "2026-02-03"
output: pdf_document
lang: en-US
format:
  html:
    embed-resources: true
---

```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, error = FALSE, 
                      message = FALSE,
                      fig.align = 'center',
                      out.width = '80%')
```


## Instructions

In this analysis I'll predict the peak bloom date over the next decade for all five locations required by the competition, using #TODO insert method here.

Current method: 
- ridge regression/lasso/elastic net
  - probably elastic net, so we can tune the alpha hyper parameter

- additional data (sunlight/UV exposure, rainfall/precipitation)
  - sunlight data from ([NOAA UV Index](https://www.cpc.ncep.noaa.gov/products/stratosphere/uv_index/uv_annual.shtml))
  - rainfall data from ([NOAA Quantitative Precipitation Forecasts](https://www.wpc.ncep.noaa.gov/qpf/day1-7.shtml))
  
  - build a model off of historic data, as well as this year's data
  - use k-fold CV to detect over fitting
  
  - do a PCA model for max predictive accuracy, in exchange for blackboxing?
  
  
TODO:
- predict a more accurate Temperature^2 threshold using historical data (linear regression or lasso/EN?)
  - use growing degree days or modified growing degree days instead of day from last frost? (research)
  - generalize a threshold value for precipitation/humidity and/or sunlight/cloudiness?

For this demo analysis we are using methods from the _tidyverse_ of R packages.

```{r}
#| eval: false
#install.packages('tidyverse')
library(tidyverse)
```


## Loading the data

The data for the five sites is provided as a simple text file in CSV format.
Each file contains the dates of the peak bloom of the cherry trees at the respective site, alongside the geographical location of the site.

The six columns in each data file are

* _location_ a human-readable location identifier (`string`).
* _lat_ (approximate) latitude of the cherry trees (`double`).
* _long_ (approximate) longitude of the cherry trees (`double`).
* _alt_ (approximate) altitude of the cherry trees (`double`).
* _year_ year of the observation (`integer`).
* *bloom_date* date of peak bloom of the cherry trees (ISO 8601 date `string`). The "peak bloom date" may be defined differently for different sites
* *bloom_doy* days since January 1st of the year until peak bloom (`integer`). January 1st corresponds to `1`.

In R, the data files can be read with `read.csv()` and concatenated with the `bind_rows()` function:

```{r}
cherry <- read.csv("data/washingtondc.csv") |> 
  bind_rows(read.csv("data/liestal.csv")) |> 
  bind_rows(read.csv("data/kyoto.csv")) |> 
  bind_rows(read.csv("data/vancouver.csv")) |> 
  bind_rows(read.csv("data/nyc.csv"))
```


## Loading additional data

We encourage you to find additional publicly-available data that will improve your predictions.
For example, one source of global meteorological data comes from the Global Historical Climatology Network (GHCN), available through the NOAA web API.

To use the web API, you first need a web service token.
You can request this token (free of charge) via <https://www.ncdc.noaa.gov/cdo-web/token>.
Once you have been issued the token, note it somewhere in your code (or make it available through an environment variable):
```{r}
#| echo: false
NOAA_WEB_API_TOKEN <- Sys.getenv("TDhcJeLNXKlnGaNsjwnNkLhwMcdfZJEq")
```

To connect to and use the web API you may use the following R packages:
```{r}
#| eval: false
#install.packages("httr2")
#install.packages("jsonlite")
library(httr2)
library(jsonlite)
```

The stations closest to the sites for the competition with continuously collected maximum temperatures are USC00186350 (Washington D.C.), GME00127786 (Liestal), JA000047759 (Kyoto), CA001108395 (Vancouver) and USW00014732 (New York).

Periods of record:
DC: 1936-09-01 to 2026-02-17
Liestal: 1901-01-01 to 2026-01-31
Kyoto: 1945-10-31 to 2026-02-01
Vancuover: 1957-01-06 to 2025-08-24
New York: 1939-10-07 to 2026-02-17
```{r}
NOAA_API_BASE_URL <- "https://www.ncei.noaa.gov/cdo-web/api/v2/data"

# Define the station IDs for the specified locations
stations <- c(
  "washingtondc" = "GHCND:USW00013743",
  "liestal"      = "GHCND:SZ000001940",
  "kyoto"        = "GHCND:JA000047759",
  "vancouver"    = "GHCND:CA001108395",
  "newyorkcity"  = "GHCND:USW00014732"
  )
```

As a simple demonstration, we retrieve the average seasonal maximum daily temperature (in 1/10 °C) from these stations using our own `get_temperature()` function, which wraps the `ghcnd_search()` function in the `rnoaa` package. (N.b. `ghcnd_search()` returns a list. Each element of the list corresponds to an element of the `var` argument.)
```{r}
nested_to_tibble <- function (x) {
  # Determine the variable names in the response
  variable_names <- map(x, names) |> 
    unlist(use.names = FALSE) |> 
    unique()
  
  names(variable_names) <- variable_names

  # Reshape the response from a nested list into a table
  map(variable_names, \(i) {
    map(x, \(y) {
      if (is.null(y[[i]])) {
        NA_character_
      } else {
        y[[i]]
      }
    }) |> 
      unlist(use.names = FALSE)
  }) |> 
    as_tibble()
}

get_daily_avg_temp <- function(station_id, start_date, end_date,
                               api_key, base_url, window_size = 300) {
  windows <- seq(as_date(start_date),
                 as_date(end_date) + days(window_size + 1),
                 by = sprintf("%d days", window_size))
  
  batches <- map2(windows[-length(windows)], windows[-1] - days(1), \(from, to) {
    if (from > Sys.Date()) {
      return(NULL)
    }
    response <- tryCatch(
      request(base_url) |> 
        req_headers(token = api_key) |> 
        req_url_query(
          datasetid = "GHCND",
          stationid = station_id,
          datatypeid = "TAVG,TMAX",
          startdate = from,
          enddate = min(as_date(to), Sys.Date()),
          units = "metric",
          limit = 1000
        ) |> 
        req_retry(max_tries = 10) |> 
        req_perform() |> 
        resp_body_json(),
      
      httr2_http = \(cnd) {
        rlang::warn(sprintf("Failed to retrieve data for station %s in time window %s--%s",
                            station_id, from, to),
                    parent = cnd)
        NULL
      })
  })
  
  map(batches, \(x) nested_to_tibble(x$results)) |> 
    list_rbind() |> 
    mutate(date = as_date(date))
}
```

Test case, getting the daily average temperature:
- in Washington DC (station_id = "GHCND:USW00013743")
- from Jan 1 2026 (start_date = 2026-01-01) to today (end_date = Sys.Date())
- with my api key (api_key = "TDhcJeLNXKlnGaNsjwnNkLhwMcdfZJEq")
- with the given base_url (base_url = "https://www.ncei.noaa.gov/cdo-web/api/v2/data")
```{r}
temperature_DC <- get_daily_avg_temp(station_id = "GHCND:USW00013743",
                                        start_date = "2026-01-01",
                                        end_date = Sys.Date(),
                                        api_key = "TDhcJeLNXKlnGaNsjwnNkLhwMcdfZJEq",
                                        base_url = "https://www.ncei.noaa.gov/cdo-web/api/v2/data")

temperature_liestal <- get_daily_avg_temp(station_id = "GHCND:SZ000001940",
                                  start_date = "2026-01-01",
                                  end_date = Sys.Date(),
                                  api_key = "TDhcJeLNXKlnGaNsjwnNkLhwMcdfZJEq",
                                  base_url = "https://www.ncei.noaa.gov/cdo-web/api/v2/data")

temperature_kyoto <- get_daily_avg_temp(station_id = "GHCND:JA000047759",
                                  start_date = "2026-01-01",
                                  end_date = Sys.Date(),
                                  api_key = "TDhcJeLNXKlnGaNsjwnNkLhwMcdfZJEq",
                                  base_url = "https://www.ncei.noaa.gov/cdo-web/api/v2/data")

temperature_vancouver <- get_daily_avg_temp(station_id = "GHCND:CA001108395",
                                  start_date = "2026-01-01",
                                  end_date = Sys.Date(),
                                  api_key = "TDhcJeLNXKlnGaNsjwnNkLhwMcdfZJEq",
                                  base_url = "https://www.ncei.noaa.gov/cdo-web/api/v2/data")

temperature_newyorkcity <- get_daily_avg_temp(station_id = "GHCND:USW00014732",
                                  start_date = "2026-01-01",
                                  end_date = Sys.Date(),
                                  api_key = "TDhcJeLNXKlnGaNsjwnNkLhwMcdfZJEq",
                                  base_url = "https://www.ncei.noaa.gov/cdo-web/api/v2/data")
```


For my use case, I want to pull: 
- temperature data ("TAVG", "TMAX")
- precipitation/humidity data ("PRCP", "RHAV")
- sunlight/cloudiness data ("TSUN", "ACSC")

(And I'd like to get each of these as separate columns, instead of factors in the datatype column.
```{r}
get_daily_data <- function(station_id, start_date, end_date,
                               api_key, base_url, window_size = 300) {
  windows <- seq(as_date(start_date),
                 as_date(end_date) + days(window_size + 1),
                 by = sprintf("%d days", window_size))
  
  batches <- map2(windows[-length(windows)], windows[-1] - days(1), \(from, to) {
    if (from > Sys.Date()) {
      return(NULL)
    }
    response <- tryCatch(
      request(base_url) |> 
        req_headers(token = api_key) |> 
        req_url_query(
          datasetid = "GHCND",
          stationid = station_id,
          datatypeid = "TAVG,TMAX,PRCP,RHAV,TSUN,ACSC",
          startdate = from,
          enddate = min(as_date(to), Sys.Date()),
          units = "metric",
          limit = 1000
        ) |> 
        req_retry(max_tries = 10) |> 
        req_perform() |> 
        resp_body_json(),
      
      httr2_http = \(cnd) {
        rlang::warn(sprintf("Failed to retrieve data for station %s in time window %s--%s",
                            station_id, from, to),
                    parent = cnd)
        NULL
      })
  })
  
  map(batches, \(x) nested_to_tibble(x$results)) |> 
    list_rbind() |> 
    mutate(date = as_date(date))
}
```

Let's test my version of the function:
```{r}
DC_Daily_Data <- get_daily_data(station_id = "GHCND:USW00013743",
                                        start_date = 2026-01-01,
                                        end_date = Sys.Date(),
                                        api_key = "TDhcJeLNXKlnGaNsjwnNkLhwMcdfZJEq",
                                        base_url = "https://www.ncei.noaa.gov/cdo-web/api/v2/data")
```

# Predicting the peak bloom using Quetelet's law

One method for predicting peak bloom is using Quetelet's law of the flowering plants. I'll reproduce it here for the cherry blossoms. Used (this article)[https://realworlddatascience.net/applied-insights/tutorials/posts/2023/04/13/flowers.html] to make the code.
```{r}
library("knitr")
#install.packages("kableExtra")
library("kableExtra")
library("tidyverse")
#install.packages("plotly")
library("plotly")
#install.packages('rnoaa', repos = c('https://ropensci.r-universe.dev', 'https://cloud.r-project.org'))
library("rnoaa")
#install.packages("rnpn")
library("rnpn")
library("rvest")
```

```{r}
#function to get a year's last frost date, in DOY
doy_last_frost <- function(tmax, doy_max = 100) {
  dof <- which(tmax[1:doy_max] <= 0)
  if(length(dof) == 0) 1 else max(dof) + 1
}

#Function to predict a year's bloom date, in DOY
doy_prediction <- function(temp, tmax, law)
  doy_last_frost(tmax) + which.max(cumsum(pmax(temp[(doy_last_frost(tmax) + 1):365], 0, na.rm = TRUE)^2) > law)

#Function to get each year's data (temperature data, bloom_date & bloom_doy, law value, and predicted bloom date) for a given location, station, and range of years. The location and station are also recorded.
#Law value here is the cumulative temperature (in °C²) from the year's last frost date to it's bloom date.
quetelet_get_data <- function(loc, ID, startDate, endDate) {
  Q_temp <- 
  ghcnd_search(stationid = ID,
               var = c("tmax", "tmin"),
               date_min = startDate,
               date_max = endDate) %>%
  reduce(left_join) %>%
  transmute(year = parse_number(format(date, "%Y")), 
            date, 
            tmax = tmax / 10, 
            tmin = tmin / 10, 
            temp = (tmax + tmin) / 2) %>% 
  drop_na()

Q_bloom <-
  cherry %>% filter(location == loc) %>% select(year, bloom_date, bloom_doy) %>%
  drop_na()

minYear <- max(c(min(Q_temp$year), min(Q_bloom$year)))
maxYear <- min(c(max(Q_temp$year), max(Q_bloom$year)))

Q_temp <- Q_temp %>% filter(year > minYear & year <= maxYear)
Q_bloom <- Q_bloom %>% filter(year > minYear & year <= maxYear)

quetelet <- 
  Q_temp %>% 
  group_by(year) %>% 
  nest() %>% 
  left_join(Q_bloom) %>% 
  mutate(law = map(data, ~ sum(pmax(.$temp, 0, na.rm = TRUE)[(doy_last_frost(.$tmax) + 1):bloom_doy]^2))) %>% 
  unnest(law) %>% 
  ungroup() %>%
  mutate(pred_bloom_doy = map(data, ~ doy_prediction(.$temp, .$tmax, mean(quetelet_dc$law)))) %>% 
  unnest(pred_bloom_doy) %>% 
  ungroup() %>%
  mutate(location = loc) %>%
  mutate(stationID = ID)
}
```


```{r}
quetelet_dc <- quetelet_get_data("washingtondc", "USW00013743", "1936-09-01", Sys.Date())
quetelet_liestal <- quetelet_get_data("liestal", "SZ000001940", "1901-01-01", Sys.Date())
quetelet_kyoto <- quetelet_get_data("kyoto", "JA000047759", "1945-10-31", Sys.Date())
quetelet_vancouver <- quetelet_get_data("vancouver", "CA001108395", "1957-01-06", Sys.Date())
quetelet_newyorkcity <- quetelet_get_data("newyorkcity", "USW00014732", "1901-01-01", Sys.Date())
```


```{r}
quetelet_analyze <- function(Qdata){
  Qdata %>%
    summarize(est = mean(law), 
            se = sd(law)/sqrt(n()),
            ci  = str_c("[", round(est - 2 * se), ", ", round(est + 2 * se), "]")) %>%
  kable(dig = 0, 
        align = "c", 
        col.names = c("estimate (°C²)", 
                      "standard error (°C²)", "95% confidence interval (°C²)"),
        caption = "Estimate of Quetelet's law.") %>%
  kable_styling()
}



quetelet_evaluate <- function(Qdata){
  Qdata %>%
    summarize(mae  = mean(abs(bloom_doy - pred_bloom_doy)),
            rmse = sqrt(mean((bloom_doy - pred_bloom_doy)^2))) %>%
  kable(dig = 0,
        align = "c",
        col.names = c("mean absolute error (days)", "root mean squared error (days)"),
        caption = "Accuracy of predictions using Quetelet's law.") %>%
  kable_styling()
}
```

```{r}
quetelet_analyze(quetelet_dc)
quetelet_evaluate(quetelet_dc)
```
```{r}
quetelet_analyze(quetelet_liestal)
quetelet_predict(quetelet_liestal)
```
```{r}
quetelet_analyze(quetelet_kyoto)
quetelet_predict(quetelet_kyoto)
```
```{r}
quetelet_analyze(quetelet_vancouver)
quetelet_predict(quetelet_vancouver)
```
```{r}
quetelet_analyze(quetelet_newyorkcity)
quetelet_predict(quetelet_newyorkcitych)
```

```{r}
#need to predict this year's bloom date using weather forecast data
#quetelet_predict_2026 <- function(Qdata, )
```


Modifications from Quetelet's method:
1) Predict a year's law value using lasso/elastic net. Then, using weather forecasts, predict what day this year will reach that law value.



```{r}
#LASSO
set.seed(8675309)
cv_5 = trainControl(method = "cv", number = 5)

threshold_elnet = train(
  #Salary ~ ., data = Hitters,
  method = "glmnet",
  trControl = cv_5
)
```

