---
title: "Liz's Peak Bloom Prediction"
author: "Liz Conley"
date: "2026-02-03"
output: pdf_document
lang: en-US
format:
  html:
    embed-resources: true
---

```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, error = FALSE, 
                      message = FALSE,
                      fig.align = 'center',
                      out.width = '80%')
```


## Instructions

In this analysis I'll predict the peak bloom date over the next decade for all five locations required by the competition, using #TODO insert method here.

Current method: 
- ridge regression/lasso/elastic net

- additional data (sunlight/UV exposure, rainfall/precipitation)
  - sunlight data from ([NOAA UV Index](https://www.cpc.ncep.noaa.gov/products/stratosphere/uv_index/uv_annual.shtml))
  - rainfall data from ([NOAA Quantitative Precipitation Forecasts](https://www.wpc.ncep.noaa.gov/qpf/day1-7.shtml))
  
  - build a model off of historic data, as well as this year's data
  - use k-fold CV to detect over fitting
  
  - do a PCA?
  
  
TODO:
- predict a more accurate Temperature^2 threshold using historical data (linear regression or lasso/EN?)
  - use growing degree days or modified growing degree days instead of day from last frost? (research)
  - generalize a threshold value for precipitation/humidity and/or sunlight/cloudiness?

For this demo analysis we are using methods from the _tidyverse_ of R packages.

```{r}
#| eval: false
#install.packages('tidyverse')
library(tidyverse)
```


## Loading the data

The data for the five sites is provided as a simple text file in CSV format.
Each file contains the dates of the peak bloom of the cherry trees at the respective site, alongside the geographical location of the site.

The six columns in each data file are

* _location_ a human-readable location identifier (`string`).
* _lat_ (approximate) latitude of the cherry trees (`double`).
* _long_ (approximate) longitude of the cherry trees (`double`).
* _alt_ (approximate) altitude of the cherry trees (`double`).
* _year_ year of the observation (`integer`).
* *bloom_date* date of peak bloom of the cherry trees (ISO 8601 date `string`). The "peak bloom date" may be defined differently for different sites
* *bloom_doy* days since January 1st of the year until peak bloom (`integer`). January 1st corresponds to `1`.

In R, the data files can be read with `read.csv()` and concatenated with the `bind_rows()` function:

```{r}
cherry <- read.csv("data/washingtondc.csv") |> 
  bind_rows(read.csv("data/liestal.csv")) |> 
  bind_rows(read.csv("data/kyoto.csv")) |> 
  bind_rows(read.csv("data/vancouver.csv")) |> 
  bind_rows(read.csv("data/nyc.csv"))
```


## Loading additional data

We encourage you to find additional publicly-available data that will improve your predictions.
For example, one source of global meteorological data comes from the Global Historical Climatology Network (GHCN), available through the NOAA web API.

To use the web API, you first need a web service token.
You can request this token (free of charge) via <https://www.ncdc.noaa.gov/cdo-web/token>.
Once you have been issued the token, note it somewhere in your code (or make it available through an environment variable):
```{r}
#| echo: false
NOAA_WEB_API_TOKEN <- Sys.getenv("TDhcJeLNXKlnGaNsjwnNkLhwMcdfZJEq")
```

To connect to and use the web API you may use the following R packages:
```{r}
#| eval: false
#install.packages("httr2")
#install.packages("jsonlite")
library(httr2)
library(jsonlite)
```

The stations closest to the sites for the competition with continuously collected maximum temperatures are USC00186350 (Washington D.C.), GME00127786 (Liestal), JA000047759 (Kyoto), CA001108395 (Vancouver) and USW00014732 (New York).

Periods of record:
DC: 1936-09-01 to 2026-02-17
Liestal: 1901-01-01 to 2026-01-31
Kyoto: 1945-10-31 to 2026-02-01
Vancuover: 1957-01-06 to 2025-08-24
New York: 1939-10-07 to 2026-02-17
```{r}
NOAA_API_BASE_URL <- "https://www.ncei.noaa.gov/cdo-web/api/v2/data"

# Define the station IDs for the specified locations
stations <- c(
  "washingtondc" = "GHCND:USW00013743",
  "liestal"      = "GHCND:SZ000001940",
  "kyoto"        = "GHCND:JA000047759",
  "vancouver"    = "GHCND:CA001108395",
  "newyorkcity"  = "GHCND:USW00014732"
  )
```

As a simple demonstration, we retrieve the average seasonal maximum daily temperature (in 1/10 °C) from these stations using our own `get_temperature()` function, which wraps the `ghcnd_search()` function in the `rnoaa` package. (N.b. `ghcnd_search()` returns a list. Each element of the list corresponds to an element of the `var` argument.)
```{r}
nested_to_tibble <- function (x) {
  # Determine the variable names in the response
  variable_names <- map(x, names) |> 
    unlist(use.names = FALSE) |> 
    unique()
  
  names(variable_names) <- variable_names

  # Reshape the response from a nested list into a table
  map(variable_names, \(i) {
    map(x, \(y) {
      if (is.null(y[[i]])) {
        NA_character_
      } else {
        y[[i]]
      }
    }) |> 
      unlist(use.names = FALSE)
  }) |> 
    as_tibble()
}

get_daily_avg_temp <- function(station_id, start_date, end_date,
                               api_key, base_url, window_size = 300) {
  windows <- seq(as_date(start_date),
                 as_date(end_date) + days(window_size + 1),
                 by = sprintf("%d days", window_size))
  
  batches <- map2(windows[-length(windows)], windows[-1] - days(1), \(from, to) {
    if (from > Sys.Date()) {
      return(NULL)
    }
    response <- tryCatch(
      request(base_url) |> 
        req_headers(token = api_key) |> 
        req_url_query(
          datasetid = "GHCND",
          stationid = station_id,
          datatypeid = "TAVG,TMAX",
          startdate = from,
          enddate = min(as_date(to), Sys.Date()),
          units = "metric",
          limit = 1000
        ) |> 
        req_retry(max_tries = 10) |> 
        req_perform() |> 
        resp_body_json(),
      
      httr2_http = \(cnd) {
        rlang::warn(sprintf("Failed to retrieve data for station %s in time window %s--%s",
                            station_id, from, to),
                    parent = cnd)
        NULL
      })
  })
  
  map(batches, \(x) nested_to_tibble(x$results)) |> 
    list_rbind() |> 
    mutate(date = as_date(date))
}
```


# Predicting the peak bloom using Quetelet's law
One method for predicting peak bloom is using Quetelet's law of the flowering plants. I'll reproduce it here for the cherry blossoms. Used (this article)[https://realworlddatascience.net/applied-insights/tutorials/posts/2023/04/13/flowers.html] to make the code.
```{r}
library("knitr")
#install.packages("kableExtra")
library("kableExtra")
library("tidyverse")
#install.packages("plotly")
library("plotly")
#install.packages('rnoaa', repos = c('https://ropensci.r-universe.dev', 'https://cloud.r-project.org'))
library("rnoaa")
#install.packages("rnpn")
library("rnpn")
library("rvest")
```

```{r}
#function to get a year's last frost date, in DOY
doy_last_frost <- function(tmax, doy_max = 100) {
  dof <- which(tmax[1:doy_max] <= 0)
  if(length(dof) == 0) 1 else max(dof) + 1
}

#Function to predict a year's bloom date, in DOY
doy_prediction <- function(temp, tmax, law)
  doy_last_frost(tmax) + which.max(cumsum(pmax(temp[(doy_last_frost(tmax) + 1):365], 0, na.rm = TRUE)^2) > law)

#Function to get each year's data (temperature data, bloom_date & bloom_doy, law value, and predicted bloom date) for a given location, station, and range of years. The location and station are also recorded.
#Law value here is the cumulative temperature (in °C²) from the year's last frost date to it's bloom date.
quetelet_get_data <- function(loc, ID, startDate, endDate) {
  Q_temp <- 
  ghcnd_search(stationid = ID,
               var = c("tmax", "tmin"),
               date_min = startDate,
               date_max = endDate) %>%
  reduce(left_join) %>%
  transmute(year = parse_number(format(date, "%Y")), 
            date, 
            tmax = tmax / 10, 
            tmin = tmin / 10, 
            temp = (tmax + tmin) / 2) %>% 
  drop_na()

Q_bloom <-
  cherry %>% filter(location == loc) %>% select(year, bloom_date, bloom_doy) %>%
  drop_na()

minYear <- max(c(min(Q_temp$year), min(Q_bloom$year)))
maxYear <- min(c(max(Q_temp$year), max(Q_bloom$year)))

Q_temp <- Q_temp %>% filter(year > minYear & year <= maxYear)
Q_bloom <- Q_bloom %>% filter(year > minYear & year <= maxYear)

quetelet <- 
  Q_temp %>% 
  group_by(year) %>% 
  nest() %>% 
  left_join(Q_bloom) %>% 
  mutate(law = map(data, ~ sum(pmax(.$temp, 0, na.rm = TRUE)[(doy_last_frost(.$tmax) + 1):bloom_doy]^2))) %>% 
  unnest(law) %>% 
  ungroup() 

quetelet <- quetelet %>%
  mutate(pred_bloom_doy = map(data, ~ doy_prediction(.$temp, .$tmax, mean(quetelet$law)))) %>% 
  unnest(pred_bloom_doy) %>% 
  ungroup() %>%
  mutate(location = loc) %>%
  mutate(stationID = ID)
}
```


```{r}
quetelet_dc <- quetelet_get_data("washingtondc", "USW00013743", "1936-09-01", Sys.Date())
quetelet_liestal <- quetelet_get_data("liestal", "SZ000001940", "1901-01-01", Sys.Date())
quetelet_kyoto <- quetelet_get_data("kyoto", "JA000047759", "1945-10-31", Sys.Date())
quetelet_vancouver <- quetelet_get_data("vancouver", "CA001108395", "1957-01-06", Sys.Date())
quetelet_newyorkcity <- quetelet_get_data("newyorkcity", "USW00014732", "1901-01-01", Sys.Date())
```


```{r}
quetelet_analyze <- function(Qdata){
  Qdata %>%
    summarize(est = mean(law), 
            se = sd(law)/sqrt(n()),
            ci  = str_c("[", round(est - 2 * se), ", ", round(est + 2 * se), "]")) %>%
  kable(dig = 0, 
        align = "c", 
        col.names = c("estimate (°C²)", 
                      "standard error (°C²)", "95% confidence interval (°C²)"),
        caption = "Estimate of Quetelet's law.") %>%
  kable_styling()
}

quetelet_evaluate <- function(Qdata){
  Qdata %>%
    summarize(mae  = mean(abs(bloom_doy - pred_bloom_doy)),
            rmse = sqrt(mean((bloom_doy - pred_bloom_doy)^2))) %>%
  kable(dig = 0,
        align = "c",
        col.names = c("mean absolute error (days)", "root mean squared error (days)"),
        caption = "Accuracy of predictions using Quetelet's law.") %>%
  kable_styling()
}
```

```{r}
quetelet_analyze(quetelet_dc)
quetelet_evaluate(quetelet_dc)
```
```{r}
quetelet_analyze(quetelet_liestal)
quetelet_evaluate(quetelet_liestal)
```
```{r}
quetelet_analyze(quetelet_kyoto)
quetelet_evaluate(quetelet_kyoto)
```
```{r}
quetelet_analyze(quetelet_vancouver)
quetelet_evaluate(quetelet_vancouver)
```
```{r}
quetelet_analyze(quetelet_newyorkcity)
quetelet_evaluate(quetelet_newyorkcity)
```

#To predict the bloom date in 2026, we'll need temperature predictions for the rest of the year. I'll use AccuWeather's predictions (haven't been able to get them all yet)
```{r}
#This draws from work by David Keplinger, link: https://dkepplinger.org/cherry/chatgpt_entry-2025.html
#It unfortunately relies on archived AccuWeather data, which is spotty for 2026 :/
get_weather_table <- function(url)
  read_html(url) %>% 
  html_nodes("div.monthly-calendar") %>% 
  html_text2() %>%
  str_replace("N/A", "N/A N/A") %>%
  str_remove_all("°|Hist. Avg. ") %>%
  str_split(" ", simplify = TRUE) %>%
  parse_number() %>%
  matrix(ncol = 3, 
         byrow = TRUE,
         dimnames = list(NULL, c("day", "tmax", "tmin"))) %>%
  as_tibble() %>%
  filter(
    row_number() %in%
      (which(diff(day) < 0) %>% (function(x) if(length(x) == 1) seq(1, x[1], 1) else seq(x[1] + 1, x[2], 1))))
```

```{r}
DC_AccuWeather <- get_weather_table("https://web.archive.org/web/20250927134342/https://www.accuweather.com/en/us/washington/20006")
#Error in open.connection(x, "rb") : cannot open the connection
```

#currently have data from 02/19/26 to 02/28/26. Need out till at least predicted bloom date, say day 151 of the year, i.e. 5/31/26, to be safe? Lot to enter by hand, need to find some way to scrape it. 
#TODO: get predicted temperature data
```{r}
AccuWeather_26_dc <- data.frame(
  year = year <- rep(2026, times = 10),
  date = date <- seq(as.Date("2026-02-19"), as.Date("2026-02-28"), "days"),
  tmax = tmax <- c(7, 12, 13, 3, 4, 3, 9, 14, 10, 16, 16, 9, 9, 10),
  tmin = tmin <- c(2, 4, 2, 1, -3, -4, 6, 1, 1, 4),
  temp = temp <- (tmax + tmin) / 2
)
#https://www.accuweather.com/en/us/washington/20006/february-weather/327659

AccuWeather_26_liestal <- data.frame(
  year = year <- rep(2026, times = 10),
  date = date <- seq(as.Date("2026-02-19"), as.Date("2026-02-28"), "days"),
  tmax = tmax <- c(10, 12.5, 9, 12, 12, 15, 16, 14, 13, 12),
  tmin = tmin <- c(4, 5.7, 6, 7, 7, 6, 5, 7, 6, 4),
  temp = temp <- (tmax + tmin) / 2
)
#https://www.accuweather.com/en/ch/liestal/311994/weather-forecast/311994
#had to interpolate the data for 2/20/26, just took the average of the rest of observations

AccuWeather_26_kyoto <- data.frame(
  year = year <- rep(2026, times = 10),
  date = date <- seq(as.Date("2026-02-19"), as.Date("2026-02-28"), "days"),
  tmax = tmax <- c(8, 15.7, 17, 21, 16, 16, 12, 17, 18, 17),
  tmin = tmin <- c(1, 6.2, 3, 9, 2, 10, 6, 8, 10, 7),
  temp = temp <- (tmax + tmin) / 2
)
#https://www.accuweather.com/en/jp/kyoto-shi/2-224436_1_al/weather-forecast/2-224436_1_al?city=kyoto
#had to interpolate the data for 2/20/26, just took the average of the rest of observations

AccuWeather_26_vancouver <- data.frame(
  year = year <- rep(2026, times = 10),
  date = date <- seq(as.Date("2026-02-19"), as.Date("2026-02-28"), "days"),
  tmax = tmax <- c(4, 4, 7, 9, 9, 8, 10, 11, 9, 9),
  tmin = tmin <- c(-1, 3, 5, 6, 5, 3, 5, 5, 3, 2),
  temp = temp <- (tmax + tmin) / 2
)
#https://www.accuweather.com/en/ca/vancouver/v6c/february-weather/53286
  
AccuWeather_26_newyorkcity <- data.frame(
  year = year <- rep(2026, times = 10),
  date = date <- seq(as.Date("2026-02-19"), as.Date("2026-02-28"), "days"),
  tmax = tmax <- c(6, 2, 9, 3, 3, 1, 5, 6, 7, 11),
  tmin = tmin <- c(2, 2, 3, -1, -2, -3, 2, 1, 1, 3),
  temp = temp <- (tmax + tmin) / 2
)
#https://www.accuweather.com/en/us/new-york/10021/february-weather/14-349727_1_al
```

```{r}
#need to predict this year's bloom date using weather forecast data
quetelet_get_2026 <- function(loc, ID, estLaw){
  #get the temperature data for all the days of this year that've happened so far
  Q_temp_26 <-
  ghcnd_search(stationid = ID,
               var = c("tmax", "tmin"),
               date_min = as_date("2026-01-01"),
               date_max = Sys.Date()) %>%
  reduce(left_join) %>%
  transmute(year = parse_number(format(date, "%Y")), 
            date, 
            tmax = tmax / 10, 
            tmin = tmin / 10, 
            temp = (tmax + tmin) / 2) %>% 
  drop_na()
  
  #add the predicted data from AccuWeather (from date of collection (2/20/2026) to 2/28)
  if (loc == "washingtondc"){
    AccuWeather_26 <- AccuWeather_26_dc
  }
  else if (loc == "liestal"){
    AccuWeather_26 <- AccuWeather_26_liestal
  }
  else if (loc == "kyoto") {
    AccuWeather_26 <- AccuWeather_26_kyoto
  }
  else if (loc == "vancouver"){
    AccuWeather_26 <- AccuWeather_26_vancouver
  }
  else if (loc == "newyorkcity"){
    AccuWeather_26 <- AccuWeather_26_newyorkcity
  }
  AccuWeather_26 <- filter(date > max(Q_temp_26$date))
  
  Q_temp_26 <- bind_rows(Q_temp_26, AccuWeather_26)
  
  #formatting
  Q_bloom_26 <-
  cherry %>% filter(location == loc) %>% select(year, bloom_date, bloom_doy) %>%
  drop_na()
  
  #more formatting
  quetelet_26 <- 
  Q_temp_26 %>% 
  group_by(year) %>% 
  nest() %>% 
  left_join(Q_bloom_26) %>% 
  mutate(law = estLaw) %>% 
  unnest(law) %>% 
  ungroup() 

  #predict the bloom date
  quetelet_26 <- quetelet_26 %>%
    mutate(pred_bloom_doy = map(data, ~ doy_prediction(.$temp, .$tmax, estLaw))) %>% 
    unnest(pred_bloom_doy) %>% 
    ungroup() %>%
    mutate(location = loc) %>%
    mutate(stationID = ID)
}
```
#TODO: make predictions for 2026
```{r}
Qdata_2026_dc <- quetelet_get_2026("washingtondc", "USW00013743", 4101)
```


#Modifications from Quetelet's method:
1) Predict an area's law value using ridge/lasso/elastic net. Then, using weather forecasts, predict what day this year will reach that law value.

```{r}
#Ridge
library(dplyr)
library(glmnet)

set.seed(8675309)
#getting data & buildig model
x <- data.matrix(quetelet_dc[, c("year", "bloom_date", "bloom_doy")])
#y <- quetelet_dc[, "law"] creating a dataframe instead of a list for some reason?
y <- quetelet_dc$law #this fixes it
lambda_seq <- 10^seq(2, -2, by = -.1)
fit <- glmnet(x, y, alpha = 0, lambda = lambda_seq)
summary(fit)

# Using cross validation glmnet
ridge_cv <- cv.glmnet(x, y, alpha = 0, lambda = lambda_seq)
best_lambda <- ridge_cv$lambda.min
best_lambda
plot(ridge_cv) # :(

best_fit <- ridge_cv$glmnet.fit
head(best_fit)

best_ridge <- glmnet(x, y, alpha = 0, lambda = best_lambda)
coef(best_ridge)

y_pred <- predict(best_ridge, s = best_lambda, newx = x)

sst <- sum((y - mean(y))^2)
sse <- sum((y_pred - y)^2)
rsq <- 1 - sse/sst
rsq
```

```{r}
write_csv(quetelet_dc, "C:/Users/ajcon/Documents/GMU Semesters/Spring 26/Stat 490/Cherry Blossoms/QuetletCSVs/quetelet_dc.csv")

write_csv(quetelet_dc$data, "C:/Users/ajcon/Documents/GMU Semesters/Spring 26/Stat 490/Cherry Blossoms/QuetletCSVs/quetelet_dc_data.csv")

quetelet_dc <- quetelet_get_data("washingtondc", "USW00013743", "1936-09-01", Sys.Date())
quetelet_liestal <- quetelet_get_data("liestal", "SZ000001940", "1901-01-01", Sys.Date())
quetelet_kyoto <- quetelet_get_data("kyoto", "JA000047759", "1945-10-31", Sys.Date())
quetelet_vancouver <- quetelet_get_data("vancouver", "CA001108395", "1957-01-06", Sys.Date())
quetelet_newyorkcity <- quetelet_get_data("newyorkcity", "USW00014732", "1901-01-01", Sys.Date())
```


#Work from the hackathon

```{r}
quetelet_get_data <- function(loc, ID, startDate, endDate) {
  Q_temp <- 
  ghcnd_search(stationid = ID,
               var = c("tmax", "tmin"),
               date_min = startDate,
               date_max = endDate) %>%
  reduce(left_join) %>%
  transmute(year = parse_number(format(date, "%Y")), 
            date, 
            tmax = tmax / 10, 
            tmin = tmin / 10, 
            temp = (tmax + tmin) / 2) %>% 
  drop_na()

Q_bloom <-
  cherry %>% filter(location == loc) %>% select(year, bloom_date, bloom_doy) %>%
  drop_na()

minYear <- max(c(min(Q_temp$year), min(Q_bloom$year)))
maxYear <- min(c(max(Q_temp$year), max(Q_bloom$year)))

Q_temp <- Q_temp %>% filter(year > minYear & year <= maxYear)
Q_bloom <- Q_bloom %>% filter(year > minYear & year <= maxYear)

quetelet <- 
  Q_temp %>% 
  group_by(year) %>% 
  nest() %>% 
  left_join(Q_bloom) %>% 
  mutate(law = map(data, ~ sum(pmax(.$temp, 0, na.rm = TRUE)[(doy_last_frost(.$tmax) + 1):bloom_doy]^2))) %>% 
  unnest(law) %>% 
  ungroup() 

quetelet <- quetelet %>%
  mutate(pred_bloom_doy = map(data, ~ doy_prediction(.$temp, .$tmax, mean(quetelet$law)))) %>% 
  unnest(pred_bloom_doy) %>% 
  ungroup() %>%
  mutate(location = loc) %>%
  mutate(stationID = ID)
}
```


```{r}
Q_temp_dc_hst <- 
  ghcnd_search(stationid = "USW00013743",
               var = c("tmax", "tmin"),
               date_min = "1936-09-01",
               date_max = Sys.Date()) %>%
  reduce(left_join) %>%
  transmute(year = parse_number(format(date, "%Y")), 
            date, 
            tmax = tmax / 10, 
            tmin = tmin / 10, 
            temp = (tmax + tmin) / 2) %>% 
  drop_na()

Q_bloom_dc_hst <-
  cherry %>% filter(location == "washingtondc") %>% select(year, bloom_date, bloom_doy) %>%
  drop_na()

minYear <- max(c(min(Q_temp_dc_hst$year), min(Q_bloom_dc_hst$year)))
maxYear <- min(c(max(Q_temp_dc_hst$year), max(Q_bloom_dc_hst$year)))

Q_temps_dc_hst <- Q_temp_dc_hst %>% filter(year > minYear & year <= maxYear)
Q_blooms_dc_hst <- Q_bloom_dc_hst %>% filter(year > minYear & year <= maxYear)

#write_csv(Q_temps_dc, "C:/Users/ajcon/Documents/GMU Semesters/Spring 26/Stat 490/Cherry Blossoms/QuetletCSVs/Q_temps_dc.csv")
#write_csv(Q_blooms_dc, "C:/Users/ajcon/Documents/GMU Semesters/Spring 26/Stat 490/Cherry Blossoms/QuetletCSVs/Q_blooms_dc.csv")
```

```{r}
AccuWeather_feb <- read_csv("C:/Users/ajcon/Documents/GMU Semesters/Spring 26/Stat 490/Cherry Blossoms/QuetletCSVs/dcPredictedTemps_February_20Thru28.csv") %>%
  mutate(year = year <- rep(2026, times = 9)) %>%
  mutate(date = date <- seq(as.Date("2026-02-20"), as.Date("2026-02-28"), "days")) %>%
  mutate(tmax = (Max - 32)*(5/9)) %>%
  mutate(tmin = (Min - 32)*(5/9)) %>%
  mutate(temp = (Avg - 32)*(5/9)) %>%
  select(year, date, tmin, tmax, temp)
  

AccuWeather_mar <- read_csv("C:/Users/ajcon/Documents/GMU Semesters/Spring 26/Stat 490/Cherry Blossoms/QuetletCSVs/dcPredictedTemps_March_2026.csv") %>%
  mutate(year = year <- rep(2026, times = 31)) %>%
  mutate(date = date <- seq(as.Date("2026-03-01"), as.Date("2026-03-31"), "days")) %>%
  mutate(tmax = (Max - 32)*(5/9)) %>%
  mutate(tmin = (Min - 32)*(5/9)) %>%
  mutate(temp = (Avg - 32)*(5/9)) %>%
  select(year, date, tmin, tmax, temp)

AccuWeather_apr <- data.frame(
  year = year <- rep(2026, times = 30),
  date = date <- seq(as.Date("2026-04-01"), as.Date("2026-04-30"), "days"),
  tmax = tmax <- c(20, 13, 15, 14, 13, 21, 19, 16, 16, 15, 16, 15, 16, 17, 16, 19, 24, 24, 18, 24, 20, 18, 17, 19, 20, 20, 23, 24, 25, 26),
  tmin = tmin <- c(8, 6, 7, 5, 5, 4, 2, 4, 4, 2, 3, 4, 4, 4, 8, 13, 11, 11, 9, 5, 5, 5, 10, 6, 7, 13, 14, 13, 15, 8),
  temp = temp <- (tmax + tmin) / 2)

AccuWeather_may <- read_csv("C:/Users/ajcon/Documents/GMU Semesters/Spring 26/Stat 490/Cherry Blossoms/QuetletCSVs/dcPredictedTemps_May_2026.csv") %>%
  mutate(year = year <- rep(2026, times = 23)) %>%
  mutate(date = date <- seq(as.Date("2026-05-01"), as.Date("2026-05-23"), "days")) %>%
  mutate(tmax = (Max - 32)*(5/9)) %>%
  mutate(tmin = (Min - 32)*(5/9)) %>%
  mutate(temp = (Avg - 32)*(5/9)) %>%
  select(year, date, tmin, tmax, temp)
  

AccuWeather_26_dc <- bind_rows(AccuWeather_feb, AccuWeather_mar, AccuWeather_apr, AccuWeather_may)
```

```{r}
quetelet_get_2026 <- function(loc, ID, estLaw){
  #get the temperature data for all the days of this year that've happened so far
  Q_temp_26 <-
  ghcnd_search(stationid = ID,
               var = c("tmax", "tmin"),
               date_min = as_date("2026-01-01"),
               date_max = Sys.Date()) %>%
  reduce(left_join) %>%
  transmute(year = parse_number(format(date, "%Y")), 
            date, 
            tmax = tmax / 10, 
            tmin = tmin / 10, 
            temp = (tmax + tmin) / 2) %>% 
  drop_na()
  
  #add the predicted data from AccuWeather (from date of collection (2/20/2026) to 2/28)
  if (loc == "washingtondc"){
    AccuWeather_26 <- AccuWeather_26_dc
  }
  else if (loc == "liestal"){
    AccuWeather_26 <- AccuWeather_26_liestal
  }
  else if (loc == "kyoto") {
    AccuWeather_26 <- AccuWeather_26_kyoto
  }
  else if (loc == "vancouver"){
    AccuWeather_26 <- AccuWeather_26_vancouver
  }
  else if (loc == "newyorkcity"){
    AccuWeather_26 <- AccuWeather_26_newyorkcity
  }
  AccuWeather_26 <- filter(date > max(Q_temp_26$date))
  
  Q_temp_26 <- bind_rows(Q_temp_26, AccuWeather_26)
  
  #formatting
  Q_bloom_26 <-
  cherry %>% filter(location == loc) %>% select(year, bloom_date, bloom_doy) %>%
  drop_na()
  
  #more formatting
  quetelet_26 <- 
  Q_temp_26 %>% 
  group_by(year) %>% 
  nest() %>% 
  left_join(Q_bloom_26) %>% 
  mutate(law = estLaw) %>% 
  unnest(law) %>% 
  ungroup() 

  #predict the bloom date
  quetelet_26 <- quetelet_26 %>%
    mutate(pred_bloom_doy = map(data, ~ doy_prediction(.$temp, .$tmax, estLaw))) %>% 
    unnest(pred_bloom_doy) %>% 
    ungroup() %>%
    mutate(location = loc) %>%
    mutate(stationID = ID)
}

Q_temp_26_dc <- quetelet_get_2026("washingtondc", "USW00013743", 4101)
```

```{r}
#get the data from NOAA up to today
Q_temp_26_dc <-
  ghcnd_search(stationid = "USW00013743",
               var = c("tmax", "tmin"),
               date_min = as_date("2026-01-01"),
               date_max = Sys.Date()) %>%
  reduce(left_join) %>%
  transmute(year = parse_number(format(date, "%Y")), 
            date, 
            tmax = tmax / 10, 
            tmin = tmin / 10, 
            temp = (tmax + tmin) / 2) %>% 
  drop_na()

#get the accuweather predictions from today to may 23
AccuWeather_26_dc <- bind_rows(AccuWeather_feb, AccuWeather_mar, AccuWeather_apr, AccuWeather_may)

#combine all the temp datasets
Q_temp_26_dc <- bind_rows(Q_temp_26_dc, AccuWeather_26_dc)

#formatting
  Q_bloom_26_dc <-
  cherry %>% filter(location == "washingtondc") %>% select(year, bloom_date, bloom_doy) %>%
  drop_na()
  
#more formatting
  quetelet_26_dc <- 
  Q_temp_26_dc %>% 
  group_by(year) %>% 
  nest() %>% 
  left_join(Q_bloom_26_dc) %>% 
  mutate(law = 4101) %>% 
  unnest(law) %>% 
  ungroup() 
  
  #predict the bloom date
  quetelet_26_dc <- quetelet_26_dc %>%
    mutate(pred_bloom_doy = map(data, ~ doy_prediction(.$temp, .$tmax, 4101))) %>% 
    unnest(pred_bloom_doy) %>% 
    ungroup() %>%
    mutate(location = "washingtondc") %>%
    mutate(stationID = "USW00013743")
  
predicted_bloom_doy_washingtondc_2026 <- quetelet_26_dc$pred_bloom_doy
predicted_bloom_doy_washingtondc_2026

quetelet_26_dc_all <- bind_rows(quetelet_dc, quetelet_26_dc)
```

```{r}

plot(x=quetelet_26_dc_all$year, y=quetelet_26_dc_all$pred_bloom_doy)

ggplot() + 
    geom_point(data=quetelet_26_dc_all, aes(x=year, y=pred_bloom_doy, color="pink3", label="Pred Bloom Dates")) + 
      geom_smooth(method=lm , color="red", se=FALSE) +#predictions
    geom_point(data=quetelet_26_dc_all, aes(x=year, y=bloom_doy, color="green4", label="Actual Bloom Dates")) +
      geom_smooth(method=lm , color="green", se=FALSE)
```

```{r}
# Libraries
library(ggplot2)
library(dplyr)
#install.packages("patchwork")
library(patchwork) # To display 2 charts together


# Most basic line chart
p1 <- ggplot(data=quetelet_26_dc_all, aes(x=year, y=pred_bloom_doy, color="pink3")) +
  geom_line(color="red", size=1) +
  ggtitle("Predicted Bloom Dates")
  
p2 <- ggplot(data=quetelet_26_dc_all, aes(x=year, y=bloom_doy, color="green4")) +
  geom_line(color="green",size=1) +
  ggtitle("Actual Bloom Dates")

# Display both charts side by side thanks to the patchwork package
p1 + p2

coeff <- 1

ggplot(data=quetelet_26_dc_all, aes(x=year)) +
  
  geom_line( aes(y=pred_bloom_doy, color="pink3")) + 
  geom_line( aes(y=bloom_doy / coeff, color="green4")) +
  
  scale_y_continuous(
    
    # Features of the first axis
    name = "Predicted Bloom DOYs",
    
    # Add a second axis and specify its features
    sec.axis = sec_axis(~.*coeff, name="Acutal Bloom DOYs")
  )
```

