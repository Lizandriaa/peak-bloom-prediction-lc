---
title: "Liz_Analysis_2"
author: "Liz Conley"
date: "2026-02-24"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Load the required libraries
```{r}
library(tidyverse)
library(httr2)
library(jsonlite)
library("knitr")
#install.packages("kableExtra")
library("kableExtra")
library("tidyverse")
#install.packages("plotly")
library("plotly")
#install.packages('rnoaa', repos = c('https://ropensci.r-universe.dev', 'https://cloud.r-project.org'))
library("rnoaa")
#install.packages("rnpn")
library("rnpn")
library("rvest")
```

#Load the provided Historical Bloom Date Data into the cherry dataset
```{r}
cherry <- read.csv("data/washingtondc.csv") |> 
  bind_rows(read.csv("data/liestal.csv")) |> 
  bind_rows(read.csv("data/kyoto.csv")) |> 
  bind_rows(read.csv("data/vancouver.csv")) |> 
  bind_rows(read.csv("data/nyc.csv"))
```

#Functions to get the historical data from NOAA, and combine it with the provided Historical Bloom Date Data
The stations closest to the sites for the competition with continuously collected maximum temperatures, and their periods of record are:
USW00013743 (Washington D.C.), 1936-09-01 to 2026-02-17
SZ000001940 (Liestal), 1901-01-01 to 2026-01-31
JA000047759 (Kyoto), 1945-10-31 to 2026-02-01
CA001108395 (Vancouver),1957-01-06 to 2025-08-24
and USW00014732 (New York), 1939-10-07 to 2026-02-17
```{r}
#NOAA API key
NOAA_WEB_API_TOKEN <- Sys.getenv("TDhcJeLNXKlnGaNsjwnNkLhwMcdfZJEq")

#Station IDs
stations <- c(
  "washingtondc" = "GHCND:USW00013743",
  "liestal"      = "GHCND:SZ000001940",
  "kyoto"        = "GHCND:JA000047759",
  "vancouver"    = "GHCND:CA001108395",
  "newyorkcity"  = "GHCND:USW00014732"
  )


#function to get bloom data for a given location (entered as a character string)
get_blooms <- function(loc){
  #get data from cherry
  blooms <- cherry %>% filter(location == loc)
  #remove columns we're not interested in
  blooms <- blooms %>% select(-"lat", -"long", -"alt")
}


#Function to get temperature data:
#from a start date (entered in "yyyy-mm-dd") to today, for a given stationID (entered as a character string)
#get temperature data from noaa
get_temps <- function(stationID, startDate){
  temps <- ghcnd_search(stationid = stationID,
               var = c("tmax", "tmin"),
               date_min = startDate,
               date_max = Sys.Date()) %>%
  reduce(left_join) %>%
  transmute(year = parse_number(format(date, "%Y")), 
            date, 
            tmax = tmax / 10, 
            tmin = tmin / 10, 
            temp = (tmax + tmin) / 2) %>% 
  drop_na() %>%
  mutate(stationID = stationID) #clean data, add stationID to dataset
  #get location from stationID
  if (stationID == "USW00013743"){
    loc <- "washingtondc"
  }
  else if (stationID == "SZ000001940"){
    loc <- "liestal"
  }
  else if (stationID == "JA000047759"){
    loc <- "kyoto"
  }
  else if (stationID == "CA001108395"){
    loc <- "vancouver"
  }
  else if (stationID == "USW00014732"){
    loc <- "newyorkcity"
  }
  #add location to dataset
  temps <- temps %>% mutate(location = loc)
  #re-order dataset
  temps <- temps[,c(7,6,1,2,3,4,5)]
}


#function to align the dates of given temperature and bloom data
allign_dates <- function(blooms, temps){
  #get the range of full years covered in both datasets
  minYear <- max(c(min(blooms$year), min(temps$year)))
  maxYear <- min(c(max(blooms$year), max(temps$year)))

  #trim each to length
  blooms <- blooms %>% filter(year > minYear & year <= maxYear)
  temps <- temps %>% filter(year > minYear & year <= maxYear)
  
  
  #join the tables
  data <- 
  temps %>% 
  group_by(year) %>% 
  nest() %>% 
  left_join(blooms)
  
  #re-organize for redability
  data <- data[,c(3,1,4,5,2)]
}


#AIO call of the above functions for one location
get_data <- function(location, stationID, startDate){
  blooms <- get_blooms(location)
  temps <- get_temps(stationID, startDate)
  data <- allign_dates(blooms, temps)
}
```

#Getting the historical data for each location
```{r}
data_washingtondc <- get_data("washingtondc", "USW00013743", "1936-09-01")
data_liestal <- get_data("liestal", "SZ000001940", "1901-01-01")
data_kyoto <- get_data("kyoto", "JA000047759", "1945-10-31")
data_vancouver <- get_data("vancouver", "CA001108395", "1957-01-06")
data_newyorkcity <- get_data("newyorkcity", "USW00014732", "1939-10-07")

```

#Getting this year's (2026) temperature data
```{r}
#get this year's predictions from accuweather
AccuWeather2026 <- read.csv("data/accuweather_forecast_2026.csv")
#format to match NOAA data
AccuWeather2026 <- AccuWeather2026 %>% mutate(stationID = "Accuweather")
AccuWeather2026$date <- as_date(AccuWeather2026$date)
AccuWeather2026 <- AccuWeather2026[,c(6,7,2,1,3,4,5)]

#split up by location
AccuWeather2026_washingtondc <- AccuWeather2026 %>% filter(location == "washington")
AccuWeather2026_liestal <- AccuWeather2026 %>% filter(location == "liestal")
AccuWeather2026_kyoto <- AccuWeather2026 %>% filter(location == "kyoto")
AccuWeather2026_vancouver <- AccuWeather2026 %>% filter(location == "vancouver")
AccuWeather2026_newyorkcity<- AccuWeather2026 %>% filter(location == "newyork")

#get this year's temperatures from NOAA (& format date to a date)
NOAA2026_washingtondc <- get_temps("USW00013743", "2026-01-01")
NOAA2026_washingtondc$date <- as_date(NOAA2026_washingtondc$date)
NOAA2026_liestal <- get_temps("SZ000001940", "2026-01-01")
NOAA2026_kyoto <- get_temps("JA000047759", "2026-01-01")
NOAA2026_vancouver <- get_temps("CA001108395", "2026-01-01")
NOAA2026_newyorkcity <- get_temps("USW00014732", "2026-01-01")

#couldn't get this to work, fix later, for now just use accuweather data on it's own
#combine, preferring NOAA's data
#temps2026_washingtondc <- left_join(x=NOAA2026_washingtondc, y=AccuWeather2026_washingtondc)
#temps2026_liestal <- 
#temps2026_kyoto <- 
#temps2026_vancouver <- 
#temps2026_newyorkcity <- 
```

#Functions for Quetelet's method
```{r}
#Function to get date of last frost, in DOY
doy_last_frost <- function(tmax, doy_max = 100) {
  dof <- which(tmax[1:doy_max] <= 0)
  if(length(dof) == 0) 1 else max(dof) + 1
}

#Function to predict a year's bloom date, in DOY
doy_prediction_quetelet <- function(temp, tmax, law)
  doy_last_frost(tmax) + which.max(cumsum(pmax(temp[(doy_last_frost(tmax) + 1):365], 0, na.rm = TRUE)^2) > law)


#function to calculate the law values for a dataset
get_law <- function(data){
  data <- data %>%
    mutate(law = map(data, ~ sum(pmax(.$temp, 0, na.rm = TRUE)[(doy_last_frost(.$tmax) + 1):bloom_doy]^2))) %>% 
    unnest(law) %>% 
    ungroup() 
}


#function to predict a year's bloom date, in DOY, using Quetelet's method
predict_quetelet <- function(data){
  mean_law <- mean(data$law)
  data <- data %>%
  mutate(pred_bloom_doy_quetelet = map(data, ~ doy_prediction_quetelet(.$temp, .$tmax, mean_law))) %>% 
  unnest(pred_bloom_doy_quetelet) %>% 
  ungroup()
}


#AIO function call for quetelet's method
quetelet_method <- function(data){
  data <- get_law(data)
  data <- predict_quetelet(data)
}
```

#Make historical predictions (training data) using quetelet's method
```{r}
quetelet_washingtondc <- quetelet_method(data_washingtondc)
quetelet_liestal <- quetelet_method(data_liestal)
quetelet_kyoto <- quetelet_method(data_kyoto)
quetelet_vancouver <- quetelet_method(data_vancouver)
quetelet_newyorkcity <- quetelet_method(data_newyorkcity)
```

#Make this year's prediction using quetelet's method
```{r}
#Function to predict the bloom date in 2026, for a given location, using Quetelet's method
predict_2026_quetelet <- function(loc) {
  if (loc == "washingtondc"){
    loc_temp <- AccuWeather2026_washingtondc$temp
    loc_tmax <- AccuWeather2026_washingtondc$tmax
    mean_law <- mean(quetelet_washingtondc$law)
  }
  else if (loc == "liestal"){
    loc_temp <- AccuWeather2026_liestal$temp
    loc_tmax <- AccuWeather2026_liestal$tmax
    mean_law <- mean(quetelet_liestal$law)
  }
  else if (loc == "kyoto"){
    loc_temp <- AccuWeather2026_kyoto$temp
    loc_tmax <- AccuWeather2026_kyoto$tmax
    mean_law <- mean(quetelet_kyoto$law)
  }
  else if (loc == "vancouver"){
    loc_temp <- AccuWeather2026_vancouver$temp
    loc_tmax <- AccuWeather2026_vancouver$tmax
    mean_law <- mean(quetelet_vancouver$law)
  }
  else if (loc == "newyorkcity"){
    loc_temp <- AccuWeather2026_newyorkcity$temp
    loc_tmax <- AccuWeather2026_newyorkcity$tmax
    mean_law <- mean(quetelet_newyorkcity$law)
  }
  
  doy <- doy_prediction_quetelet(loc_temp, loc_tmax, mean_law)
}

bloom_doy_2026_washingtondc <- predict_2026_quetelet("washingtondc")
bloom_date_2026_washingtondc <- as.Date(bloom_doy_2026_washingtondc, origin = "2026-01-01")

bloom_doy_2026_liestal <- predict_2026_quetelet("liestal")
bloom_date_2026_liestal <- as.Date(bloom_doy_2026_liestal, origin = "2026-01-01")

bloom_doy_2026_kyoto <- predict_2026_quetelet("kyoto")
bloom_date_2026_kyoto <- as.Date(bloom_doy_2026_kyoto, origin = "2026-01-01")

bloom_doy_2026_vancouver <- predict_2026_quetelet("vancouver")
bloom_date_2026_vancouver <- as.Date(bloom_doy_2026_vancouver, origin = "2026-01-01")

bloom_doy_2026_newyorkcity <- predict_2026_quetelet("newyorkcity")
bloom_date_2026_newyorkcity <- as.Date(bloom_doy_2026_newyorkcity, origin = "2026-01-01")
```

-----------------------

#Functions for GDD/MGDD method
Similar to Quetelet's method, Growing Degree Days (GDDs) and Modified Growing Degree Days (MGDDs) are a cumulative sum of some time-temperature quantity that predict a plant's bloom date.

Growing degree days are calculated for each day as: ((tmax-tmin)/2)-base.
Base is a threshold temperature below which a plant does not develop. It is a mechanistic value, need to consult research to determine a base temp for cherry blossoms. 
In agricultural applications, 10c is a common base temperature for Corn, Soybeans, Tomatoes, Turfgrass, 4.4c is a common base temperature for Wheat, Alfalfa, many insects, and 0c is a common base for specific perennial crops.

Growing degree days are calculated for each day as: (((tmax<=upper_bound)-(tmin>=base))/2)-base.
Modified growing degree days are calculated similarly to standard GDDs, except the daily tmax and tmin temperatures are adjusted based on some maximum & minimum thresholds. The upper threshold is also mechanistic, and the lower threshold is commonly the base value.

Similarly to Quetelet's method, there is some required amount of cumulative GDDs/MGDDs for a plant to bloom. 

Similar to Growing Degree Days/Modified Growing Degree Days, Winter Chill Days (WCDs) and Chill Portions (CPs) are a cumulative sum of some time-temperature quantity that predict a plant's bloom date.

Winter Chill Days are calculated for each day as: base-(tmax-tmin).
Base is a threshold temperature above which a plant does not do winter dormancy. It is a mechanistic value, need to consult research to determine a base temp for cherry blossoms.

Winter Portions are calculated for each day as: base - ((tmax<=upper_bound)-(tmin>=base))/2
(((tmax<=upper_bound)-(tmin>=base))/2)-base.
Winter Portions are calculated similarly to standard WCD, except the daily tmax and tmin temperatures are adjusted based on some maximum & minimum thresholds. The upper threshold is also mechanistic, (commonly 7c or 12c) and the lower threshold is commonly the base value.

Similarly to Quetelet's method, there is some required amount of cumulative GDDs/MGDDs for a plant to bloom. 
```{r}
#Do regular GDDs first (need to determine best base value)
#then MGDDs if time permits (need to determine best upper & lower bounds)

#Function to get start of GDD period, in DOY (from first day GDD is positive)
doy_first_GDD <- function(temp, base_temp = 0, doy_max = 100) {
  #gets list of days where GDD is positive
  GDDs <- which(((temp[1:doy_max])-base_temp) > 0)
  #gets first day where GDD is positive
  if(length(GDDs) == 0) 1 else min(GDDs)
}


#Function to predict a year's bloom date, in DOY
doy_prediction_GDD <- function(temp, tmax, law)
  doy_last_frost(tmax) + which.max(cumsum(pmax(temp[(doy_last_frost(tmax) + 1):365], 0, na.rm = TRUE)^2) > law)


#function to calculate the GDD_score for a dataset
  #GDD_score = cumulative GDD values from first day of year where GDD is positive
get_GDD_score <- function(data, base_temp = 0){
  data <- data %>%
    mutate(GDD_score = map(data, ~ sum(pmax(((.$temp)-base_temp), 0, na.rm = TRUE)[(doy_first_GDD(.$temp) + 1):bloom_doy]))) %>% 
    unnest(GDD_score) %>% 
    ungroup() 
}

#function to predict a year's bloom date, in DOY, using GDD method
predict_GDD <- function(data){
  mean_GDD_score <- mean(data$GDD_score)
  data <- data %>%
  mutate(pred_bloom_doy_GDD = map(data, ~ doy_prediction_GDD(.$temp, .$tmax, mean_GDD_score))) %>% 
  unnest(pred_bloom_doy_GDD) %>% 
  ungroup()
}


#AIO function call for GDD method (counting GDDs from first positive GDD, using base_temp of 0c)
GDD_method <- function(data){
  data <- get_GDD_score(data)
  data <- predict_GDD(data)
}


GDD_washingtondc <- GDD_method(data_washingtondc)

```

#Functions for GDD/MGDD method attempt 2
In testing above, results were worse than Quetelet's method. Let's try a different approach.

Better understanding of GDDs:
There are two periods of interest for which GDDs are used, the endo-dormant phase (winter chill -> chilling days) and eco-dormant phase (GDD/MGDD -> warming days).
Degree Days are calculated the same for both, the mean temperature above or below some threshold value (above for warming, below for cooling. They do not have to be the same threshold value, but can be. They can also be adjusted to have opposite extreme cutoff values past which the Degree Days are not calculated, this is the concept behind modified growing degree days.)
The cumulative degree days are what is used to predict bloom, similar to cumulative temperature in Quetelet's.

Cumulative Warming Days are calculated from some initial warming date until the bloom date. In lab studies of the Yoshino Cherry Tree (Prunus x yedoensis) the initial warming date is the first day in which the rolling average temperature over 5-10 days is above (at or above?) some threshold value, usually 2-3c. There does not seem to be an upper bound temperature above which growing degree days should be capped, although some studies have used 30-32c as an upper bound. (test w/out, and then with.)

Cumulative Cooling Days are calculated from some initial cooling date until some final cooling date. Deriving from the intital warming date, the initial cooling date ought to be the first day in which the rolling average temperature over 5-10 days is below (at or below?) some threshold value. Likewise, the final cooling date ought to be the last day before the rolling average temperature over 5-10 days is above some threshold value. I'm unsure what threshold value to use here, perhaps the same threshold for warming days (2-3c), perhaps freezing (0c) or perhaps something else.
There does seem to be a lower bound temperature below which cooling degree days should be capped. Yoshino Cherry Trees are in the USDA hardiness zone 5-8, which says that temperatures below the range of -23c to -18c can be harmful to the tree.

Before I was just summing the degree days to get the cumulative degree days, but the Baskerville-Emin method looks like something worth exploring: draw a curve of average temperatures, then take the area between that curve and the threshold/cutoff values.


#Get the temperature data
I'm also going to do the data wrangling slightly differently than previously, and try to avoid creating tables by location.
```{r}
#function to get all temps for specific locations from minimum date range to present
#takes in a vector of station IDs and a vector of corresponding start dates 
get_all_temps <- function(stationIDs, startDates){
  temps <- get_temps(stationIDs[1], startDates[1])
  counter = 2;
  while (counter <= length(stationIDs)){
    temps <- bind_rows(temps, get_temps(stationIDs[counter], startDates[counter]))
    counter <- counter+1
  }
  temps
}

stationIDs <- c(
  "washingtondc" = "USW00013743",
  "liestal"      = "SZ000001940",
  "kyoto"        = "JA000047759",
  "vancouver"    = "CA001108395",
  "newyorkcity"  = "USW00014732"
  )

startDates <- c(
  "washingtondc" = "1936-09-01",
  "liestal"      = "1901-01-01",
  "kyoto"        = "1945-10-31",
  "vancouver"    = "1957-01-06",
  "newyorkcity"  = "1939-10-07"
)

all_temps <- get_all_temps(stationIDs, startDates)
```
#Rolling average is needed for later calculations, so I'll go ahead and calculate it here & add it to the temperature data.
TODO: tidy up, implement as function to choose rolling days amount (between 5 & 10)
```{r}
#install.packages("zoo")
library(zoo)
all_temps2 <- all_temps %>%
  group_by(location) %>%
  arrange(date) %>%
  mutate(roll5_temp = rollmean(temp, k = 5, fill = NA, align = "right")) %>%
  ungroup()
```

#Calculate each day's Warming Degree Days and Cooling Degree Days
Using lower threshold of 3c and upper threshold of 30c (to start with, can tune these later.)
warming day value = 
                    if (tmax>=upper & tmin<= lower){= ((upper+lower)/2)-lower}
                    else if (tmax>=upper){= ((upper+tmin)/2)-lower}
                    else if (tmin<=lower){= ((tmax+lower)/2)-lower}
                    else{= temp-lower}

Using an upper threshold of 3c and a lower threshold of -18c (to start with, can tune these later.)
cooling day value = 
                    if (tmax>=upper & tmin<= lower){= ((upper+lower)/2)+upper}
                    else if (tmax>=upper){= ((upper+tmin)/2)+upper}
                    else if (tmin<=lower){= ((tmax+lower)/2)+upper}
                    else{= temp-lower}
```{r}
#function to calculate warming degree day value (WDD) from tmax and tmin, given an upper and lower bound
get_WDD <- function(tmax, tmin, temp, upper=30, lower=3){
  WDD_value <- 0
  if (tmax>=upper && tmin<= lower){WDD_value = ((upper+lower)/2)-lower}
  else if (tmax>=upper){WDD_value = ((upper+tmin)/2)-lower}
  else if (tmin<=lower){WDD_value = ((tmax+lower)/2)-lower}
  else{WDD_value = temp-lower}
}

#function to calculate cooling degree day value (WDD) from tmax and tmin, given an upper and lower bound
get_CDD <- function(tmax, tmin, temp, upper=3, lower=-18){
  CDD_value <- 0
  if (tmax>=upper && tmin<= lower){CDD_value = ((upper+lower)/2)+upper}
  else if (tmax>=upper){CDD_value = ((upper+tmin)/2)+upper}
  else if (tmin<=lower){CDD_value = ((tmax+lower)/2)+upper}
  else{CDD_value = temp-lower}
}

#function to add Warming Degree Days (WDD) and Cooling Degree Days (CDD) to the temperature data
#add_degree_days <- function(data, warming_upper=30, warming_lower=3, cooling_upper=3, cooling_lower=-18){
#  data <- data %>% 
#    mutate(WDD <- get_WDD(.$tmax, .$tmin, warming_upper, warming_lower))
#}

#function to add Warming Degree Days (WDD) and Cooling Degree Days (CDD) to the temperature data
#add_degree_days <- function(data, warming_upper=30, warming_lower=3, cooling_upper=3, cooling_lower=-18){
#  data <- data %>% 
#    mutate(WDD = map(data, get_WDD(tmax, tmin, temp, warming_upper, warming_lower))) #%>%
#    unnest(WDD) %>%
#    ungroup()
#}

#function to add Warming Degree Days (WDD) and Cooling Degree Days (CDD) to the temperature data
#it's a fuck ass loop, this prolly isn't sigma big-O or whatever but I couldn't get map() to work
add_degree_days <- function(data, warming_upper=30, warming_lower=3, cooling_upper=3, cooling_lower=-18){
  counter <- 1
  WDD <- vector(mode="double", length=length(data$temp))
  CDD <- vector(mode="double", length=length(data$temp))
  while(counter<=length(data$temp)){
    WDD[counter] <- get_WDD(data$tmax[counter], data$tmin[counter], data$temp[counter], warming_upper, warming_lower)
    CDD[counter] <- get_CDD(data$tmax[counter], data$tmin[counter], data$temp[counter], cooling_upper, cooling_lower)
    counter <- counter+1
  }
  data$WDD <- WDD
  data$CDD <- CDD
  data
}


all_DDs <- all_temps2 %>% add_degree_days()
```

#Calculate each year's cumulative Warming Degree Days and cumulative Cooling Degree Days
For cooling degree days, need to go back to the previous year's winter most likely - might be a pain to calculate.
```{r}
#TODO: fix/make different allign_dates that preserves bloom dates & bloom doys

allign_dates <- function(blooms, temps){
  minYear <- max(c(min(blooms$year), min(temps$year)))
  maxYear <- min(c(max(blooms$year), max(temps$year)))

  #trim each to length
  blooms <- blooms %>% filter(year > minYear & year <= maxYear)
  temps <- temps %>% filter(year > minYear & year <= maxYear)
  
  
  #join the tables
  data <- 
  temps %>% 
  group_by(year) %>% 
  nest() %>% 
  left_join(blooms)
  
  #re-organize for redability
  data <- data[,c(3,1,4,5,2)]
}

#this is a jank fix, but it works! TODO: make the fix less jank
allign_dates2 <- function(blooms, temps){
  blooms <- blooms %>%
    group_by(location)
}

all_data <- allign_dates2(cherry, all_DDs)
all_data <- all_data %>% arrange(location, year)

#function to get a year's initial warming date (the first day in which the rolling average temperature over 5-10 days is above (at or above?) warming_lower bound, default to 3c.
doy_initial_warming <- function(roll5_temp, doy_max = 100, warming_lower=3) {
  dof <- which(roll5_temp[1:doy_max] >= warming_lower)
  if(length(dof) == 0) 1 else min(dof)
}

#Function to get a year's cumulative WDD between it's initial warming date & it's bloom date
get_warming <- function(data){
  data <- data %>%
    mutate(warming = map(data, ~ sum(pmax(.$WDD, 0, na.rm = TRUE)[(doy_initial_warming(.$roll5_temp)):bloom_doy]))) %>% 
    unnest(warming) %>% 
    ungroup() 
}

all_data_warming <- get_warming(all_data)
#Function to get a year's cumulative CDD between the initial warming date (the first day in which the rolling average temperature over 5-10 days is above (at or above?) warming_lower bound, default to 3c.

```


#Predict based on cumulative Warming Degree Days and cumulative Cooling Degree Days
```{r}

```

#Use law/cumulative temperature, cumulative Warming Degree Days and cumulative Cooling Degree Days in a random forrest or XGBoost to get the best of all 3 models
```{r}

```

