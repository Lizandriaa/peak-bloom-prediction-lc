---
title: "Liz_Analysis_2"
author: "Liz Conley"
date: "2026-02-24"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Load the required libraries
```{r}
library(tidyverse)
library(httr2)
library(jsonlite)
library("knitr")
#install.packages("kableExtra")
library("kableExtra")
library("tidyverse")
#install.packages("plotly")
library("plotly")
#install.packages('rnoaa', repos = c('https://ropensci.r-universe.dev', 'https://cloud.r-project.org'))
library("rnoaa")
#install.packages("rnpn")
library("rnpn")
library("rvest")
```

#Load the provided Historical Bloom Date Data into the cherry dataset
```{r}
cherry <- read.csv("data/washingtondc.csv") |> 
  bind_rows(read.csv("data/liestal.csv")) |> 
  bind_rows(read.csv("data/kyoto.csv")) |> 
  bind_rows(read.csv("data/vancouver.csv")) |> 
  bind_rows(read.csv("data/nyc.csv"))
```

#Functions to get the historical data from NOAA, and combine it with the provided Historical Bloom Date Data
The stations closest to the sites for the competition with continuously collected maximum temperatures, and their periods of record are:
USW00013743 (Washington D.C.), 1936-09-01 to 2026-02-17
SZ000001940 (Liestal), 1901-01-01 to 2026-01-31
JA000047759 (Kyoto), 1945-10-31 to 2026-02-01
CA001108395 (Vancouver),1957-01-06 to 2025-08-24
and USW00014732 (New York), 1939-10-07 to 2026-02-17
```{r}
#NOAA API key
NOAA_WEB_API_TOKEN <- Sys.getenv("TDhcJeLNXKlnGaNsjwnNkLhwMcdfZJEq")

#Station IDs
stations <- c(
  "washingtondc" = "GHCND:USW00013743",
  "liestal"      = "GHCND:SZ000001940",
  "kyoto"        = "GHCND:JA000047759",
  "vancouver"    = "GHCND:CA001108395",
  "newyorkcity"  = "GHCND:USW00014732"
  )


#function to get bloom data for a given location (entered as a character string)
get_blooms <- function(loc){
  #get data from cherry
  blooms <- cherry %>% filter(location == loc)
  #remove columns we're not interested in
  blooms <- blooms %>% select(-"lat", -"long", -"alt")
}


#Function to get temperature data:
#from a start date (entered in "yyyy-mm-dd") to today, for a given stationID (entered as a character string)
#get temperature data from noaa
get_temps <- function(stationID, startDate){
  temps <- ghcnd_search(stationid = stationID,
               var = c("tmax", "tmin"),
               date_min = startDate,
               date_max = Sys.Date()) %>%
  reduce(left_join) %>%
  transmute(year = parse_number(format(date, "%Y")), 
            date, 
            tmax = tmax / 10, 
            tmin = tmin / 10, 
            temp = (tmax + tmin) / 2) %>% 
  drop_na() %>%
  mutate(stationID = stationID) #clean data, add stationID to dataset
  #get location from stationID
  if (stationID == "USW00013743"){
    loc <- "washingtondc"
  }
  else if (stationID == "SZ000001940"){
    loc <- "liestal"
  }
  else if (stationID == "JA000047759"){
    loc <- "kyoto"
  }
  else if (stationID == "CA001108395"){
    loc <- "vancouver"
  }
  else if (stationID == "USW00014732"){
    loc <- "newyorkcity"
  }
  #add location to dataset
  temps <- temps %>% mutate(location = loc)
  #re-order dataset
  temps <- temps[,c(7,6,1,2,3,4,5)]
}


#function to align the dates of given temperature and bloom data
allign_dates <- function(blooms, temps){
  #get the range of full years covered in both datasets
  minYear <- max(c(min(blooms$year), min(temps$year)))
  maxYear <- min(c(max(blooms$year), max(temps$year)))

  #trim each to length
  blooms <- blooms %>% filter(year > minYear & year <= maxYear)
  temps <- temps %>% filter(year > minYear & year <= maxYear)
  
  
  #join the tables
  data <- 
  temps %>% 
  group_by(year) %>% 
  nest() %>% 
  left_join(blooms)
  
  #re-organize for redability
  data <- data[,c(3,1,4,5,2)]
}


#AIO call of the above functions for one location
get_data <- function(location, stationID, startDate){
  blooms <- get_blooms(location)
  temps <- get_temps(stationID, startDate)
  data <- allign_dates(blooms, temps)
}
```

#Getting the historical data for each location
```{r}
data_washingtondc <- get_data("washingtondc", "USW00013743", "1936-09-01")
data_liestal <- get_data("liestal", "SZ000001940", "1901-01-01")
data_kyoto <- get_data("kyoto", "JA000047759", "1945-10-31")
data_vancouver <- get_data("vancouver", "CA001108395", "1957-01-06")
data_newyorkcity <- get_data("newyorkcity", "USW00014732", "1939-10-07")

```

#Getting this year's (2026) temperature data
```{r}
#get this year's predictions from accuweather
AccuWeather2026 <- read.csv("data/accuweather_forecast_2026.csv")
#format to match NOAA data
AccuWeather2026 <- AccuWeather2026 %>% mutate(stationID = "Accuweather")
AccuWeather2026$date <- as_date(AccuWeather2026$date)
AccuWeather2026 <- AccuWeather2026[,c(6,7,2,1,3,4,5)]

#split up by location
AccuWeather2026_washingtondc <- AccuWeather2026 %>% filter(location == "washington")
AccuWeather2026_liestal <- AccuWeather2026 %>% filter(location == "liestal")
AccuWeather2026_kyoto <- AccuWeather2026 %>% filter(location == "kyoto")
AccuWeather2026_vancouver <- AccuWeather2026 %>% filter(location == "vancouver")
AccuWeather2026_newyorkcity<- AccuWeather2026 %>% filter(location == "newyork")

#get this year's temperatures from NOAA (& format date to a date)
NOAA2026_washingtondc <- get_temps("USW00013743", "2026-01-01")
NOAA2026_washingtondc$date <- as_date(NOAA2026_washingtondc$date)
NOAA2026_liestal <- get_temps("SZ000001940", "2026-01-01")
NOAA2026_kyoto <- get_temps("JA000047759", "2026-01-01")
NOAA2026_vancouver <- get_temps("CA001108395", "2026-01-01")
NOAA2026_newyorkcity <- get_temps("USW00014732", "2026-01-01")

#couldn't get this to work, fix later, for now just use accuweather data on it's own
#combine, preferring NOAA's data
#temps2026_washingtondc <- left_join(x=NOAA2026_washingtondc, y=AccuWeather2026_washingtondc)
#temps2026_liestal <- 
#temps2026_kyoto <- 
#temps2026_vancouver <- 
#temps2026_newyorkcity <- 
```

#Functions for Quetelet's method
```{r}
#Function to get date of last frost, in DOY
doy_last_frost <- function(tmax, doy_max = 100) {
  dof <- which(tmax[1:doy_max] <= 0)
  if(length(dof) == 0) 1 else max(dof) + 1
}

#Function to predict a year's bloom date, in DOY
doy_prediction_quetelet <- function(temp, tmax, law)
  doy_last_frost(tmax) + which.max(cumsum(pmax(temp[(doy_last_frost(tmax) + 1):365], 0, na.rm = TRUE)^2) > law)


#function to calculate the law values for a dataset
get_law <- function(data){
  data <- data %>%
    mutate(law = map(data, ~ sum(pmax(.$temp, 0, na.rm = TRUE)[(doy_last_frost(.$tmax) + 1):bloom_doy]^2))) %>% 
    unnest(law) %>% 
    ungroup() 
}


#function to predict a year's bloom date, in DOY, using Quetelet's method
predict_quetelet <- function(data){
  mean_law <- mean(data$law)
  data <- data %>%
  mutate(pred_bloom_doy_quetelet = map(data, ~ doy_prediction_quetelet(.$temp, .$tmax, mean_law))) %>% 
  unnest(pred_bloom_doy_quetelet) %>% 
  ungroup()
}


#AIO function call for quetelet's method
quetelet_method <- function(data){
  data <- get_law(data)
  data <- predict_quetelet(data)
}
```

#Make historical predictions (training data) using quetelet's method
```{r}
quetelet_washingtondc <- quetelet_method(data_washingtondc)
quetelet_liestal <- quetelet_method(data_liestal)
quetelet_kyoto <- quetelet_method(data_kyoto)
quetelet_vancouver <- quetelet_method(data_vancouver)
quetelet_newyorkcity <- quetelet_method(data_newyorkcity)
```

#Make this year's prediction using quetelet's method
```{r}
#Function to predict the bloom date in 2026, for a given location, using Quetelet's method
predict_2026_quetelet <- function(loc) {
  if (loc == "washingtondc"){
    loc_temp <- AccuWeather2026_washingtondc$temp
    loc_tmax <- AccuWeather2026_washingtondc$tmax
    mean_law <- mean(quetelet_washingtondc$law)
  }
  else if (loc == "liestal"){
    loc_temp <- AccuWeather2026_liestal$temp
    loc_tmax <- AccuWeather2026_liestal$tmax
    mean_law <- mean(quetelet_liestal$law)
  }
  else if (loc == "kyoto"){
    loc_temp <- AccuWeather2026_kyoto$temp
    loc_tmax <- AccuWeather2026_kyoto$tmax
    mean_law <- mean(quetelet_kyoto$law)
  }
  else if (loc == "vancouver"){
    loc_temp <- AccuWeather2026_vancouver$temp
    loc_tmax <- AccuWeather2026_vancouver$tmax
    mean_law <- mean(quetelet_vancouver$law)
  }
  else if (loc == "newyorkcity"){
    loc_temp <- AccuWeather2026_newyorkcity$temp
    loc_tmax <- AccuWeather2026_newyorkcity$tmax
    mean_law <- mean(quetelet_newyorkcity$law)
  }
  
  doy <- doy_prediction_quetelet(loc_temp, loc_tmax, mean_law)
}

bloom_doy_2026_washingtondc <- predict_2026_quetelet("washingtondc")
bloom_date_2026_washingtondc <- as.Date(bloom_doy_2026_washingtondc, origin = "2026-01-01")

bloom_doy_2026_liestal <- predict_2026_quetelet("liestal")
bloom_date_2026_liestal <- as.Date(bloom_doy_2026_liestal, origin = "2026-01-01")

bloom_doy_2026_kyoto <- predict_2026_quetelet("kyoto")
bloom_date_2026_kyoto <- as.Date(bloom_doy_2026_kyoto, origin = "2026-01-01")

bloom_doy_2026_vancouver <- predict_2026_quetelet("vancouver")
bloom_date_2026_vancouver <- as.Date(bloom_doy_2026_vancouver, origin = "2026-01-01")

bloom_doy_2026_newyorkcity <- predict_2026_quetelet("newyorkcity")
bloom_date_2026_newyorkcity <- as.Date(bloom_doy_2026_newyorkcity, origin = "2026-01-01")
```

#Functions for GDD/MGDD method
Similar to Quetelet's method, Growing Degree Days (GDDs) and Modified Growing Degree Days (MGDDs) are a cumulative sum of some time-temperature quantity that predict a plant's bloom date.

Growing degree days are calculated for each day as: ((tmax-tmin)/2)-base.
Base is a threshold temperature below which a plant does not develop. It is a mechanistic value, need to consult research to determine a base temp for cherry blossoms. 
In agricultural applications, 10c is a common base temperature for Corn, Soybeans, Tomatoes, Turfgrass, 4.4c is a common base temperature for Wheat, Alfalfa, many insects, and 0c is a common base for specific perennial crops.

Growing degree days are calculated for each day as: (((tmax<=upper_bound)-(tmin>=base))/2)-base.
Modified growing degree days are calculated similarly to standard GDDs, except the daily tmax and tmin temperatures are adjusted based on some maximum & minimum thresholds. The upper threshold is also mechanistic, and the lower threshold is commonly the base value.

Similarly to Quetelet's method, there is some required amount of cumulative GDDs/MGDDs for a plant to bloom. 
```{r}
#Do regular GDDs first (need to determine best base value)
#then MGDDs if time permits (need to determine best upper & lower bounds)

#Function to get start of GDD period, in DOY (from first day GDD is positive)
doy_first_GDD <- function(temp, base_temp = 0, doy_max = 100) {
  #gets list of days where GDD is positive
  GDDs <- which(((temp[1:doy_max])-base_temp) > 0)
  #gets first day where GDD is positive
  if(length(GDDs) == 0) 1 else min(GDDs)
}


#Function to predict a year's bloom date, in DOY
doy_prediction_GDD <- function(temp, tmax, law)
  doy_last_frost(tmax) + which.max(cumsum(pmax(temp[(doy_last_frost(tmax) + 1):365], 0, na.rm = TRUE)^2) > law)


#function to calculate the GDD_score for a dataset
  #GDD_score = cumulative GDD values from first day of year where GDD is positive
get_GDD_score <- function(data, base_temp = 0){
  data <- data %>%
    mutate(GDD_score = map(data, ~ sum(pmax(((.$temp)-base_temp), 0, na.rm = TRUE)[(doy_first_GDD(.$temp) + 1):bloom_doy]))) %>% 
    unnest(GDD_score) %>% 
    ungroup() 
}

#function to predict a year's bloom date, in DOY, using GDD method
predict_GDD <- function(data){
  mean_GDD_score <- mean(data$GDD_score)
  data <- data %>%
  mutate(pred_bloom_doy_GDD = map(data, ~ doy_prediction_GDD(.$temp, .$tmax, mean_GDD_score))) %>% 
  unnest(pred_bloom_doy_GDD) %>% 
  ungroup()
}


#AIO function call for GDD method (counting GDDs from first positive GDD, using base_temp of 0c)
GDD_method <- function(data){
  data <- get_GDD_score(data)
  data <- predict_GDD(data)
}


GDD_washingtondc <- GDD_method(data_washingtondc)

```
#Functions for GDD/MGDD method


#Make historical predictions (training data) using GDD/MGDD method
```{r}
#TODO
```

#Functions for WCD/CP method
Similar to Growing Degree Days/Modified Growing Degree Days, Winter Chill Days (WCDs) and Chill Portions (CPs) are a cumulative sum of some time-temperature quantity that predict a plant's bloom date.

Winter Chill Days are calculated for each day as: base-(tmax-tmin).
Base is a threshold temperature above which a plant does not do winter dormancy. It is a mechanistic value, need to consult research to determine a base temp for cherry blossoms.

Winter Portions are calculated for each day as: base - ((tmax<=upper_bound)-(tmin>=base))/2
(((tmax<=upper_bound)-(tmin>=base))/2)-base.
Winter Portions are calculated similarly to standard WCD, except the daily tmax and tmin temperatures are adjusted based on some maximum & minimum thresholds. The upper threshold is also mechanistic, (commonly 7c or 12c) and the lower threshold is commonly the base value.

Similarly to Quetelet's method, there is some required amount of cumulative GDDs/MGDDs for a plant to bloom. 
```{r}
#TODO
```

#Make historical predictions (training data) using Winter Chill Days method
```{r}
#TODO
```

#Functions to get this year's temperature data from NOAA and AccuWeather, and format it properly
```{r}
#TODO
```

#Getting this year's data for each location
```{r}
#TODO
```
